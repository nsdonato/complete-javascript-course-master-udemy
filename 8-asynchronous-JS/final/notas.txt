# Asincronismo en javascript

  * Asincronico
    - Codigo que se ejecuta en segundo plano, mientras nuestro codigo principal sigue ejecutando.
    - Tipicalmente se usa para pedir datos del servidor o una api.     Un timer setTimeout, es asincronico. Porque llama a una función después de un tiempo determinado. Se ejecuta en segundo plano.
    - En su callback se pasa una funcion que queremos que se ejecute cuando termine el procesamiento.

  * Sincronico se ejecuta linea por linea.
    Si se ejecuta algo sincronico antes de que cargue la pagina, la pagina podria quedar cargada por la mitad, y encima no se podia clicear ni nada por el estilo.

  * WEB APIS

    - Viven fuera del motor de Javascript, son cosas como:
        . Metodos de manipulación de DOM
        . setTimeout
        . solicitudes HTTP por ajax
        . geolocalización
        . almacenamiento local, etc..

# Loop event

  Cuando creamos un setTimeout, este se crea en el stack de ejecución junto con la función de callback
   pero a su vez, esta en el entorno de las web api, y se mantiene ahí hasta que pase su trabajo.
   cuando termina de ejecuarse, en vez de volver al stack de ejecución, va a la cadena de ejecución y para mostrase como sabemos, hay que esperar que el stack de ejecució este vacio.
   Por ultimo el evento loop la lleva hacia un nuevo contexto de ejecución donde se ejecuta la funcion callback.

# callback hell

    se le dice cuando tenes una llamada tras otra anidada de x ej setTimeout.


# PROMESAS

    "Prometeme que vas a obtener ese dato, así lo puedo manejar en el futuro"
    - Una promesa es un objeto que mantiene el trackeo de si un evento pasó o no.
    - Determina que hacer si el evento sucedió
    - Implementa un concepto de "un futuro valor que estamos esperando"
    - Todos los objetos promesa, heredan los metodos then y catch
    Las promesas tienen diferentes estados:

        - Pending | Pendiente: antes de que pase el evento.
        - Settled / Resolved | "Colocado / Resuelto": después que el evento pasó:
        - Fulfilled | "Cumplido" : Promesa cumplida, resultado exitoso, el resultado esta disponible.
        - Rejected | "Rechazada" : Hubo un error.
    
        const getIDs = new Promise((resolve, reject) => {
        // lo que esta aca adentro se le llama " funcion ejecutora ", toma 2 parametros

        //     setTimeout(() => {
        //         resolve([523, 883, 432, 974]);   // lo que queremos retornar cuando salio todo ok
        //     }, 1500);
        // });

        .then(PASAMOScallbackfunction(1arg)) > nos permite adherir un manejador de eventos si la promesa esta cumplida "fulfilled"
                el parametro en la función callback es el resultado de la promesa cumplida.

        .catch(error => {
            // manejamos el error que hubo
        })

        para manejar mas de 1 promesa, ponemos un .then abajo del otro

# AJAX y APIS

    # AJAX 
        Significa Javascript asincrónico y XML. Básicamente, nos permite comunicarnos de forma asíncrona con servidores remotos.
        También para enviar datos al servidor haciendo una solicitud posterior en lugar de una solicitud de obtención.
        
        API significa Application Programming Interface y en un nivel muy alto, es básicamente una pieza de software que puede ser utilizada por otra pieza de
        software para básicamente permitir que las aplicaciones se comuniquen entre sí.
        
        Dos tipos de API que puedes usar en Javascript: API (tu propia api donde brindas info sobre tu sistema) o API externas de terceros (api que hizo alguien para que puedas obtener cierta información)

# Fetch

    API web moderna llamada Fetch. Una de las API web que está disponible en el navegador, son parte del lenguaje JavaScript.

    HttpRequest en realidad, tiene mejor compatibilidad con el navegador que Fetch, ya que ha existido desde hace mucho tiempo.

Pero todavía voy a utilizar Fetch

ahora mismo en esta conferencia, que es

más moderna y debería funcionar más que bien para nosotros aquí.

Y entonces probemos ahora.

Así que voy a deshacerme de este código aquí primero, al

igual que antes.

Bueno.

Entonces, todo lo que tenemos que

hacer es realmente usar la función de búsqueda.

Así que solo así.

Ahora aquí tenemos que pasar

la URL donde se encuentra la API.

Así que, básicamente, la URL a la que estamos enviando la solicitud.

Ahora estamos usando una API meteorológica llamada MetaWeather.

Entonces, hablemos un poco sobre eso.

Ya lo tengo abierto aquí, así que está en metaweather. com / api y esta

página aquí es básicamente una documentación simple

de esta API.

Por lo tanto, normalmente las API solicitan una clave para poder usarla,

pero esta es muy simple y no

requiere una clave API, por eso escogí esta muy simple

API de MetaWeather.

Bueno.

Así que aquí tenemos

la documentación y podemos ver aquí que hay tres

métodos en esta API.

Entonces, el primero aquí

es buscar ubicaciones.

Básicamente, pones el nombre de una ciudad o

algo así y luego vuelve con un resultado

que contiene estos campos aquí en la respuesta.

Así que el título de la ubicación, el tipo, la

latitud y la longitud, este ID aquí, que significa Where On Earth

ID, y luego esta distancia aquí.

Bueno.

Ahora bien, este no

es el que queremos usar, pero queremos utilizar este método

de ubicación aquí.

Esto es básicamente para obtener los datos meteorológicos

de un cierto ID de Where On Earth.

Entonces esta ID aquí

corresponde a un lugar en la Tierra.

Así que este es el método API, o el punto final

API, que también podemos llamarlo, que nos interesa.

Aquí abajo tenemos algunos ejemplos,

así que vamos a verlo aquí para San

Francisco, que en realidad es el que vamos a usar.

Vamos a abrir en una nueva pestaña y luego verá esta respuesta.

Ahora quizás para ti se vea así en el navegador, así

que probablemente esto es lo que ves.

Pero tengo instalada esta

práctica extensión de Chrome que se llama

JSON Viewer.

Lo hace muy bien formateado y más fácil

de leer, así como así.

Como ven aquí, esta es la URL de la

llamada API, así que metaweather. com / API / location que es

el punto final, entonces cual es el método que estamos

usando, y luego también pasamos el ID de Where On Earth,

que es este número aquí, ¿no?

Entonces, solo siguiendo el formato que tenemos aquí

en esta documentación, ¿de acuerdo?

Entonces, lo que obtenemos en este momento es este objeto aquí, que

no es realmente un objeto, sino que se llama JSON.

Y entonces JSON es

un formato de datos basado en texto que es muy

similar a los objetos de JavaScript, pero la diferencia es

que JSON es realmente una sola cadena y no un

objeto completo dentro del motor de JavaScript.

Esto es como una cadena que podemos recibir del servidor

y luego podemos convertirlo fácilmente en un objeto JavaScript.

Voy a mostrarte cómo funciona eso en un

segundo cuando comenzamos a usar esta API.

Por ahora, echemos un vistazo al resultado

aquí y lo que tenemos es que el primer campo es el clima consolidado y,

por lo tanto, obtenemos una variedad del clima en días diferentes.

El primero es para el 15 de marzo, y verá la temperatura mínima, la

velocidad máxima del viento, la dirección del viento, la presión del aire

y todas las cosas buenas así.

Luego tenemos lo mismo para el 16, 17, 18 y 19 de marzo,

e incluso 20. Entonces creo que

es un pronóstico de cinco días.

Luego, además de esa matriz, también tenemos la hora actual,

el amanecer, el atardecer, la zona horaria y todos estos datos aquí.

Así que podemos obtener todo esto simplemente llamando a la API en este punto

final de ubicación con este ID aquí.

Entonces básicamente con

este parámetro

Esto funciona como un parámetro

que pasamos a la API, simplemente utilizándolo en la

URL que llamamos.

Así que vamos a usar este aquí.

Todo lo

que tenemos que hacer es pasar este en la búsqueda como una cadena.

Y aquí vamos.

Eso es.

Parece un poco extraño porque se movió a

una nueva línea aquí.

Lo ideal sería que en una línea se viera así, está bien,

pero no tenemos espacio para eso,

así es como se ve.

Ahora solo para probar lo que sucede aquí, echémosle un vistazo.

Bueno.

Así que ahora obtenemos este extraño error diciendo

que no hay control de acceso permitido encabezado de origen está

presente en el recurso solicitado.

Entonces, ¿qué es este extraño error?

Bueno, la razón de esto es la llamada política

de origen en JavaScript, que básicamente nos impide

hacer solicitudes AJAX a un dominio diferente de nuestro

propio dominio.

Así que ahora no tenemos ningún

dominio aquí, solo estamos abriendo el archivo JavaScript.

Y el dominio del que

estamos solicitando este recurso es, por supuesto,

la API de MetaWeather.

Y así, debido a esta misma

política de origen, no podemos acceder a este recurso.

Ahora, para permitir que

los desarrolladores realicen solicitudes a

diferentes dominios, se desarrolló algo llamado

Cross Origin Resource Sharing o CORS.

No quiero aburrirlo con todos los

detalles aquí, pero en términos simples, los desarrolladores

de la API que estamos solicitando, deben implementar CORS

en su servidor.

Ese es realmente el caso

para muchas API, pero desafortunadamente no para MetaWeather.

Así que esto es un problema, pero afortunadamente aún

podemos resolverlo.

Entonces, lo que los desarrolladores suelen

hacer es proxy o canalizar la solicitud a través de

su propio servidor.

Como hacer las solicitudes AJAX en nuestro propio

servidor donde no existe la misma política de

origen y luego enviar los datos al navegador.

Entonces esto es solo una solución a ese problema.

Pero, por supuesto, no vamos a hacer

eso aquí porque no tenemos nuestro propio servidor en este ejemplo, y

por supuesto queremos hacerlo simple.

Pero aún podemos usar un servicio

que hace exactamente eso por nosotros.

Vamos a usar un proxy

llamado crossorigin. yo.

Déjame que te lo muestre.

Eso está mal escrito.

Así que crossorigin. yo.

Y aquí dice lo que hace.

Un proxy CORS es un servicio que permite a los desarrolladores acceder

a los recursos de otros sitios web,

sin tener que poseer ese sitio web.

Y en realidad es muy fácil de usar.

Todo lo que tenemos

que hacer es prefijar nuestra propia URL de solicitud con este crossorigin. yo.

Así que vamos a probar esto y

ponerlo aquí, y eso ya debería ser suficiente.

Vamos a volver a cargarlo

Y ahora no obtenemos ningún error, pero tampoco obtenemos ningún

resultado, ¿verdad?

Y eso es porque aún

no manejamos el resultado de esta función de búsqueda.

Así que simplemente cancelamos la solicitud, pero eso es todo

lo que hicimos.

No manejamos ninguna respuesta

ni nada de eso.

Entonces, ocupémonos de eso.

Bueno.

Lo que necesita saber es que la

API de obtención obtiene nuestros datos y devuelve una promesa.

Y esta promesa, por

supuesto, puede devolver los datos que queremos, o un

error si de alguna manera no podía encontrar los datos que solicitamos.

Así que ahora podemos usar los métodos de captura y entonces

de esta promesa, tal como te mostré en las últimas conferencias.

Entonces, ¿recuerdas que mencioné que la mayoría de

las veces solo consumimos promesas y realmente no

las producimos?

Y este es un gran ejemplo de eso.

Buscar aquí automáticamente devuelve una promesa sin que nosotros

mismos tengamos que escribir una promesa.

Entonces lo estamos consumiendo aquí.

Ahora usemos el método then en él,

y también el catch.

Nuestra función de devolución de llamada aquí tiene un argumento y ese

es el valor de resolución de la promesa.

¿Recuerda eso?

Vamos a llamarlo algo así como resultado.

Esto significa que los datos que provienen de esta

solicitud AJAX de búsqueda se denominarán resultado aquí en esta función de

devolución de llamada.

Entonces, simplemente registremos en la consola.

El punto de la consola registra el resultado.

Y agreguemos la devolución de llamada aquí para el caso

de que haya un error.

Vamos a registrarlo también en la consola.

Veamos cómo funciona eso.

¡Y bien!

Entonces ahora ves este objeto de respuesta aquí.

Tiene todos estos campos aquí, pero lo que realmente

nos importa es este campo corporal.

Lo que ves ahora aquí

es que es una transmisión legible.

Eso es un poco raro.

Lo que esto significa es que primero tenemos que

procesar esta respuesta aquí con JSON para que podamos obtener el resultado

real que estamos buscando.

Entonces, el cuerpo aquí es

donde se almacena el resultado real, pero ahora es el

flujo legible.

De hecho, tenemos que convertirlo de

JSON a JavaScript tal como lo mencioné antes.

¿Cómo hacemos eso?

Bueno, en realidad es muy fácil.

Simplemente usamos el

método JSON en este resultado.

Y este método JSON, también

devuelve una promesa.

Entonces tenemos que manejar el resultado

de eso y así nuevamente, usamos el método de entonces.

Y también lo encadenamos como lo hicimos en la conferencia anterior.

¿Recuerda eso?

Al igual que antes, podemos devolver una

promesa aquí y luego agregar un nuevo método luego de esto.

Entonces, operaciones de encadenamiento o asincrónicas aquí,

una después de la otra.

Devuelva el resultado

del punto

JSON.

Por lo tanto, esto aquí devolverá

una promesa, ya que esto sucede de manera asíncrona, esta

conversión a JSON, porque puede llevar algo de tiempo, por

lo que ocurre de forma asíncrona en segundo plano.

Tan pronto como esté listo, luego regresa con los datos.

Entonces tenemos que manejar eso y entonces agregamos un nuevo método.

Así que vamos a llamar a estos datos ahora,

y simplemente registremos en la consola una vez más.

Disparemos.

Y aquí vamos.

Nuestro objeto JavaScript ahora contiene los

datos que estábamos buscando.

Genial, ¿verdad?

Así que acabamos de hacer nuestra primera llamada

AJAX usando fetch y promesas.

Si ahora echas un vistazo a esto, esta

sería la información exacta que tenemos aquí en este ejemplo.

Así que tienes los datos del clima aquí, que es una matriz.

Tiempo tan consolidado, luego esta matriz con todos estos

días, y luego los datos restantes que tenemos aquí.

Y ves que esto sigue siendo San Francisco.

Entonces, todo lo que necesitamos está realmente aquí.

Ahora, para hacer esto un poco

más divertido, logremos registrar algo más

emocionante para la consola que solo este objeto completo, ¿de acuerdo?

No queremos registrar todo esto en la consola, sino que simplemente tengamos este clima

aquí el primer día y luego registremos

algunas cadenas en la consola

para saber cómo es el clima hoy.

Así que contar hoy

es información porque ese es todo el objeto aquí.

Entonces hemos consolidado el clima.

Copiemos este de aquí.

Recuerde que esta es la matriz, y luego

hoy es, por supuesto, la primera.

Entonces, número cero.

Así que eso es

hoy, y vamos a registrar en

la consola algún tipo de cadena.

Estamos usando cadenas de plantillas aquí.

Las temperaturas en, agreguemos el nombre de la ciudad.

Ves este está almacenado en este título.

Así que tenemos el

título de

punto de datos en medio, así que solo usemos la temperatura máxima

y la temperatura mínima.

Entonces es mínimo y máximo.

Vamos a escribirlo, eso es más fácil.

Así que hoy tenemos la temperatura mínima de punto

y hoy la temperatura máxima de punto.

Bien.

Vamos a ver.

Toma un tiempo obtener

los datos, y luego las temperaturas en San

Francisco se mantienen entre 7. 52 y 11. 36 grados Celsius.

Así que esto probablemente está en los grados

Celsius aquí, que es lo que usamos fuera de los EE. UU., Como probablemente sabrá.

Tan estupendo.

Pongamos esto tal vez en una función.

Digamos la función getWeather y

luego le damos el

ID de Where On Earth,

para hacer esto un poco más reutilizable.

getWeather, entonces usamos este aquí, como nuestra ID.

Entonces aquí solo queremos esta ID.

Entonces, usemos una cadena de plantilla aquí.

Oops, eso no es, sí.

Bien.

Así que echemos un vistazo al ejemplo.

Entonces otro más aquí es Londres.

Entonces el ID aquí es este.

Entonces, llamemos ahora

también a Londres.

Entonces getWeather.

Y entonces probemos ahora.

Y está bien.

Entonces San Francisco es el

primero y el segundo es Londres.

Entonces está funcionando bien.

Ahora veamos qué sucede si ponemos aquí

un número extraño que realmente no arroja ningún resultado.

Algo así, que probablemente no sea una identificación

válida, así que veamos.

Y entonces, lo que tenemos aquí

primero es un 404, así que básicamente esto significa que no encontró nada.

Así que eso es un error que

viene directamente desde la línea 98 desde esta función de búsqueda aquí.

Pero luego también obtenemos este error aquí, que es

el tipo error que no se puede leer la propiedad

cero de indefinido.

Y eso viene de la línea 108 y

eso significa que en algún lugar de esta

cadena hubo un error.

Y ahora podemos agregar más lógica aquí

en este método de captura para manejar ese error correctamente.

Pero esto fue solo para mostrarte un ejemplo.

Lo que realmente queremos es, por

supuesto, que esto funcione bien.

Y eso es.

Esa es una llamada AJAX muy simple que

usa fetch y promesas usando then y los métodos catch.

Espero que tenga sentido para ti.

Cómo usamos fetch, cómo

manejamos el resultado y cómo lo convertimos a JSON,

que devuelve esta nueva promesa.

Luego, aquí simplemente

analizamos la respuesta, y basándonos en eso, simplemente

imprimimos los datos en la consola

que estamos interesados ​​aquí.

Así que así es como lo haces con el método de captura y

entonces para manejar esta promesa.

Pero en la próxima conferencia

voy a mostrarte cómo podemos usar

async / await nuevamente para manejar los datos que regresan

del servidor.

Entonces, una vez más, verán

que en realidad es mucho más fácil y agradable de usar también.

Así que estad atentos para la próxima conferencia.
 